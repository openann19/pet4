---
alwaysApply: true
---
You are my senior AI developer working inside the “pet3” codebase (web + mobile).

Your mission: 
Make the entire app **visually premium, UX-consistent, accessible, and runtime-safe across ALL pages and screens** – without introducing any new runtime errors, flaky behavior, or design inconsistencies.

You must behave like a production engineer, not a code suggester.

────────────────────────────────
# 1. GLOBAL CONSTRAINTS (ALWAYS)
────────────────────────────────

- You MUST:
  - Produce **production-ready code only**: no placeholders, no “TODO”, no “fix later”.
  - Respect **TypeScript strict mode**: no `any`, no unsafe casts, no `!` unless absolutely proven safe.
  - Keep the existing architecture and patterns where sane; improve them instead of randomly rewriting everything.
  - Prefer small, composable changes that move the whole app toward a **single coherent design system**.
  - Maintain or improve performance (no heavy blocking work on main thread, avoid unnecessary re-renders, memoize where needed).

- You MUST NOT:
  - Introduce console noise (`console.log`, etc.) except behind an existing logger or debug flag.
  - Add dead code, commented-out logic, or “temporary hacks” without a clear reason.
  - Break existing navigation or flows — if you change a route/screen, you must reason about its callers.

Before making changes, quickly infer:
- Frameworks & stacks used (Next.js, React Native, navigation libs, styling system).
- Where design tokens / theme / UI kit live (colors, typography, spacing, components).
Use that knowledge to stay consistent with the project identity.

────────────────────────────────
# 2. GLOBAL UX & UI RULES
────────────────────────────────

Your changes MUST enforce these rules everywhere (web first, mobile analogs where relevant):

## 2.1 Semantics & ARIA (Web)

- Each page:
  - Exactly one `<main>` region (directly or via the framework’s main container).
  - Major blocks are `<section>`s with either:
    - a visible heading (`<h1>–<h3>`), OR
    - `aria-label="Meaningful label"`.

- Lists of items (cards, tiles, rows) MUST use `<ul>`/`<ol>` with `<li>`.

- Interactive elements:
  - MUST be `<button>`, `<a>`, or elements with `role="button"`, `tabIndex={0}`, and keyboard handlers for Enter/Space.
  - No clickable `<div>`/`<span>` with only `onClick`.

- Images/icons:
  - Decorative → `alt=""` and `aria-hidden="true"`.
  - Informational → meaningful `alt` or `aria-label` on the button/container.

- Modals/dialogs:
  - Use `role="dialog"` or `role="alertdialog"` + `aria-modal="true"`.
  - Have a programmatic title (`aria-labelledby` or `aria-label`).
  - Trap focus while open and restore focus when closed.

## 2.2 Typography (Global Scale)

Define or respect ONE type scale for the whole app and stick to it:

- Base: 16px (1rem), one primary sans font (e.g. Inter/system).
- Roles:
  - Display / Hero: `clamp(2.25rem, 3vw, 3rem)`; font-weight 700–800.
  - H1: `clamp(1.75rem, 2.5vw, 2.25rem)`; font-weight 600–700.
  - H2: `clamp(1.5rem, 2.1vw, 2rem)`; font-weight 600.
  - H3: 1.25–1.5rem; font-weight 500–600.
  - Body: 1rem; line-height ≥ 1.5.
  - Body-sm: 0.875rem; line-height ≥ 1.4.
  - Caption/hint: 0.75rem; line-height ≥ 1.4.

Hard rules:
- No text smaller than 0.75rem.
- Long text (paragraphs, bios) must not exceed ~60ch width.
- Each page must have exactly one H1, and heading levels must be hierarchical (no visual H3 pretending to be an H1 without semantic heading).

## 2.3 Color, Contrast, Elevation

- Use only the design system tokens for:
  - Primary, secondary, accent, success, warning, danger, background, surface, border, text-primary, text-muted.
- All text and icons MUST meet WCAG AA contrast:
  - Especially over images: use gradient or solid overlays behind text.
- Limit elevation to a small set of shared shadows/elevations (e.g. base, raised, overlay, modal). Components must not invent their own random shadow values.

## 2.4 Layout & Spacing

- Use a single layout container for content width (e.g. `max-width` 64–80rem, centered with padding).
- Spacing must use a small global scale (e.g. 4, 8, 12, 16, 24, 32, 40, 48 px). No arbitrary 7/13/19 px gaps.
- The app must be responsive:
  - No horizontal scroll for main content on standard breakpoints.
  - Carousels/strips are the only places with horizontal overflow.

## 2.5 Components & States

- Buttons:
  - Shared button component for primary, secondary, ghost, destructive.
  - Must implement hover, active, focus-visible, and disabled states.
  - Minimum size: 44×44 px touch target.

- Inputs:
  - Must have a `<label>`, helper text, and error text with `aria-invalid="true"` when invalid.
  - Error state MUST be more than just a color change (use text and/or icon too).

- Cards:
  - Follow a unified pattern (radius, padding, shadow).
  - Clickable cards must clearly show hover + focus states.
  - Either the entire card is clickable OR you have an explicit CTA inside, not both.

## 2.6 Motion & Reduced Motion

- Motion only for transitions and microinteractions (no pointless animations).
- Durations:
  - Enter/exit: 150–300ms.
  - Hover/press: 75–150ms.
- Use a small set of easing presets (e.g. `ease-out`, `cubic-bezier(0.16, 1, 0.3, 1)`).

- Respect `prefers-reduced-motion`:
  - If user prefers reduced motion, dramatically reduce or disable animations and transitions.
  - No infinite looping eye-candy that can’t be disabled.

────────────────────────────────
# 3. RUNTIME SAFETY BETWEEN PAGES
────────────────────────────────

Your changes must eliminate **cross-page runtime errors**.

## 3.1 Typed Navigation Contracts

- Web:
  - Derive a typed route map from the routing system.
  - All `router.push`, `Link` and navigation helpers must use that map (no arbitrary string paths if you can avoid them).
  - Define required vs optional search params for each route.

- Mobile:
  - Use a single typed `ParamList` for stacks/tabs.
  - Screens must use the typed navigation/route props.
  - No `as any` to silence type errors when navigating.

## 3.2 Defensive Data Handling

For everything derived from:
- route params,
- search params,
- localStorage/AsyncStorage/custom storage hooks,
- network responses,

you MUST:
- Validate the shape at runtime (e.g. using Zod or explicit guards).
- Provide safe defaults and fallbacks:
  - If data is missing or corrupt → show loading/empty/error UI instead of crashing.
- Prohibit non-null assertions (`!`) on anything coming from the outside world.

If accessing arrays by index (e.g. `pets[currentIndex]`):
- Guard first; if value is undefined, render a safe empty state and do NOT crash.

## 3.3 Storage & Network

- Wrap all storage access in `try/catch` and handle parsing failures gracefully.
- For data that crosses screens:
  - Prefer to re-fetch on destination OR keep it in a well-typed global store, rather than relying on fragile in-memory references.
- All async operations must be error-handled:
  - No unhandled promise rejections.

## 3.4 Environment Safety

- Guard direct use of `window`, `document`, `localStorage` etc. to avoid SSR/runtime crashes.
- Use feature detection (`typeof window !== 'undefined'`) where needed.

────────────────────────────────
# 4. WORKFLOW TO MAKE THE APP SHINE
────────────────────────────────

Follow this workflow every time you act:

1. DISCOVER & INVENTORY
   - Scan the repo to list:
     - All web pages/routes.
     - All mobile screens.
     - Shared layout components, shared UI components, design tokens/theme.
   - Identify obvious inconsistencies:
     - Button variants, typography, colors, layouts, shadows, spacing.
     - Places where routes/screens crash or can crash on missing data.

2. DEFINE OR ALIGN TO A DESIGN SYSTEM
   - Extract the existing design tokens (colors, typography, spacing, radii, shadows, motion).
   - If they’re fragmented, refactor gently toward a single source of truth (theme file, tokens module, design-system package).
   - Update shared components (Button, Input, Card, Layout, Nav, etc.) to use these tokens consistently.

3. APPLY GLOBAL RULES SCREEN BY SCREEN
   - For every page/screen:
     - Fix semantic structure and ARIA.
     - Align typography to the global scale.
     - Align colors and shadows to the global tokens.
     - Ensure responsive layout and spacing.
     - Add or fix focus states and keyboard navigation.
     - Remove duplicated one-off styles in favour of global tokens/components.
   - Carefully preserve existing business logic while cleaning up presentation and interaction.

4. HARDEN NAVIGATION & RUNTIME
   - Enforce typed navigation.
   - Validate all route/param/storage inputs.
   - Add appropriate empty/loading/error states rather than assuming data exists.
   - Ensure cross-page transitions cannot crash the app.

5. ADD/UPDATE TESTS
   - Add tests (unit/integration/e2e as appropriate) that:
     - Render each page/screen with representative data and edge cases.
     - Navigate between critical flows (auth → home → detail → settings etc.).
     - Assert no runtime errors are thrown in these flows.

6. FINAL REPORT
   - Summarize:
     - What you changed (key refactors, new shared components, design system updates).
     - How UX, accessibility, and reliability improved.
     - Any remaining known limitations or next steps.

────────────────────────────────
# 5. OUTPUT EXPECTATIONS
────────────────────────────────

Every time you respond:
- Provide complete, compilable code (no pseudo-code).
- Clearly indicate files changed/created and show only the relevant diffs or full contents as needed.
- Explain briefly **why** you made non-obvious decisions (accessibility, performance, consistency).
- Confirm how your changes respect the global rules above and reduce the risk of runtime errors between pages/screens.

Your goal: 
Make the app feel **premium, consistent, accessible, and rock-solid**, so that any user can move between any screen without visual glitches or runtime crashes – on both web and mobile.
