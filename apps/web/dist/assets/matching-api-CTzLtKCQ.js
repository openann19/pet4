var e=Object.defineProperty,t=(t,r,n)=>((t,r,n)=>r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[r]=n)(t,"symbol"!=typeof r?r+"":r,n);import{b6 as r,f as n,aa as i,ab as a}from"./feature-admin-g8AIjMAb.js";import{d as o}from"./view-ChatView.tsx-DI-Ea8ls.js";import"./react-vendor-atdIga2R.js";import"./vendor-B2U5onNE.js";import"./utils-vendor-7mYxNw04.js";import"./ui-vendor-CttiZxwU.js";import"./feature-adoption-C919WvgL.js";import"./feature-community-DxZ7YsOF.js";import"./feature-chat-CPR2_-OR.js";import"simple-peer";import"./view-AdoptionView.tsx-BJlxubb2.js";const s={temperamentFit:20,energyLevelFit:10,lifeStageProximity:10,sizeCompatibility:10,speciesBreedCompatibility:15,socializationCompatibility:10,intentMatch:10,distance:10,healthVaccinationBonus:5},c={allowCrossSpecies:!1,requireVaccinations:!0,blockAggressionConflicts:!0,requireApprovedMedia:!0,enforceNeuterPolicy:!0,maxDistanceKm:50},d=n("RealtimeEvents");class g{constructor(e){t(this,"wsManager"),t(this,"pendingAcks",new Map),t(this,"ackTimeout",5e3),this.wsManager=e}async sendWithAck(e,t,r){const n=this.wsManager.send(e,t,r);return new Promise((e,r)=>{const i=window.setTimeout(()=>{this.pendingAcks.delete(n),r(new Error(`Event acknowledgment timeout: ${t}`))},this.ackTimeout);this.pendingAcks.set(n,{resolve:()=>{clearTimeout(i),this.pendingAcks.delete(n),e()},reject:e=>{clearTimeout(i),this.pendingAcks.delete(n),r(e)},timeout:i}),this.wsManager.on("message_acknowledged",e=>{if(e.messageId===n){const e=this.pendingAcks.get(n);e&&e.resolve()}}),this.wsManager.on("message_failed",e=>{const t=e;if(t.messageId===n){const e=this.pendingAcks.get(n);e&&e.reject(new Error(`Event failed: ${t.event}`))}})})}async joinRoom(e,t){d.debug("Joining room",{roomId:e,userId:t}),await this.sendWithAck("/chat","join_room",{roomId:e,userId:t})}async sendMessage(e){d.debug("Sending message",{messageId:e.id,roomId:e.chatRoomId}),await this.sendWithAck("/chat","message_send",{messageId:e.id,roomId:e.chatRoomId,content:e.content,senderId:e.senderId,type:e.type,timestamp:e.createdAt})}async markMessageDelivered(e,t,r){d.debug("Marking message delivered",{messageId:e,roomId:t,recipientId:r}),await this.sendWithAck("/chat","message_delivered",{messageId:e,roomId:t,recipientId:r})}async markMessageRead(e,t,r){d.debug("Marking message read",{messageId:e,roomId:t,readerId:r}),await this.sendWithAck("/chat","message_read",{messageId:e,roomId:t,readerId:r})}async setTyping(e,t,r){d.debug("Setting typing status",{roomId:e,userId:t,isTyping:r}),await this.sendWithAck("/chat","typing",{roomId:e,userId:t,isTyping:r})}async userOnline(e){d.debug("User online",{userId:e}),await this.sendWithAck("/presence","user_online",{userId:e,lastSeenAt:(new Date).toISOString()})}async userOffline(e){d.debug("User offline",{userId:e}),await this.sendWithAck("/presence","user_offline",{userId:e,lastSeenAt:(new Date).toISOString()})}async notifyMatchCreated(e){d.debug("Match created notification",{matchId:e.id}),await this.sendWithAck("/notifications","match_created",{match:e})}async notifyLikeReceived(e,t){d.debug("Like received notification",{fromPetId:e,toPetId:t}),await this.sendWithAck("/notifications","like_received",{fromPetId:e,toPetId:t})}async notifyStoryViewed(e,t,r){d.debug("Story viewed notification",{storyId:e,viewerId:t,petId:r}),await this.sendWithAck("/notifications","story_viewed",{storyId:e,viewerId:t,petId:r})}onChatMessage(e){return this.wsManager.on("chat:message_send",e)}onMessageDelivered(e){return this.wsManager.on("chat:message_delivered",e)}onMessageRead(e){return this.wsManager.on("chat:message_read",e)}onTyping(e){return this.wsManager.on("chat:typing",e)}onUserOnline(e){return this.wsManager.on("presence:user_online",e)}onUserOffline(e){return this.wsManager.on("presence:user_offline",e)}onMatchCreated(e){return this.wsManager.on("notifications:match_created",e)}onLikeReceived(e){return this.wsManager.on("notifications:like_received",e)}onStoryViewed(e){return this.wsManager.on("notifications:story_viewed",e)}}let h=null;function p(){if(!h){const e=new r({url:o.current.WS_URL});h=new g(e)}return h}const I=n("MatchingAPI");class m{constructor(){t(this,"configCache",null)}async discover(e){try{return(await i.post(a.MATCHING.DISCOVER,e)).data}catch(t){const r=t instanceof Error?t:new Error(String(t));throw I.error("Failed to discover candidates",r,{petId:e.petId}),r}}async score(e){try{return(await i.post(a.MATCHING.SCORE,e)).data}catch(t){const r=t instanceof Error?t:new Error(String(t));throw I.error("Failed to calculate match score",r,{petId1:e.petId1,petId2:e.petId2}),r}}async swipe(e){try{const t=(await i.post(a.MATCHING.SWIPE,e)).data;if(t.isMatch&&t.matchId){const r=p();await r.notifyMatchCreated({id:t.matchId,petAId:e.petId,petBId:e.targetPetId,compatibilityScore:0,compatibilityBreakdown:{personality:0,interests:0,size:0,age:0,location:0,overall:0},status:"active",chatRoomId:t.chatRoomId||"",createdAt:(new Date).toISOString(),lastInteractionAt:(new Date).toISOString()}).catch(e=>{I.error("Failed to emit match_created event",e instanceof Error?e:new Error(String(e)))})}else if("like"===e.action||"superlike"===e.action){const t=p();await t.notifyLikeReceived(e.petId,e.targetPetId).catch(e=>{I.error("Failed to emit like_received event",e instanceof Error?e:new Error(String(e)))})}return t}catch(t){const r=t instanceof Error?t:new Error(String(t));throw I.error("Failed to record swipe",r,{petId:e.petId,targetPetId:e.targetPetId}),r}}async getMatches(e){try{return(await i.get(`${a.MATCHING.MATCHES}?petId=${e}`)).data.matches}catch(t){const r=t instanceof Error?t:new Error(String(t));throw I.error("Failed to get matches",r,{petId:e}),r}}async getPreferences(e){try{return(await i.get(`${a.MATCHING.PREFERENCES}?ownerId=${e}`)).data.preferences}catch(t){const r=t instanceof Error?t:new Error(String(t));throw I.error("Failed to get preferences",r,{ownerId:e}),r}}async updatePreferences(e,t){try{return(await i.put(a.MATCHING.PREFERENCES,{ownerId:e,...t})).data.preferences}catch(r){const t=r instanceof Error?r:new Error(String(r));throw I.error("Failed to update preferences",t,{ownerId:e}),t}}async reportPet(e){try{await i.post("/matching/report",e),I.info("Pet reported",{reporterPetId:e.reporterPetId,reportedPetId:e.reportedPetId,reason:e.reason})}catch(t){const r=t instanceof Error?t:new Error(String(t));throw I.error("Failed to report pet",r,{reporterPetId:e.reporterPetId}),r}}async getConfig(){if(this.configCache)return this.configCache;try{const e=await i.get("/matching/config");return this.configCache=e.data.config,e.data.config}catch(e){I.warn("Failed to get matching config, using defaults",e instanceof Error?e:new Error(String(e)));const t={id:"default",weights:s,hardGates:c,featureFlags:{MATCH_ALLOW_CROSS_SPECIES:!1,MATCH_REQUIRE_VACCINATION:!0,MATCH_DISTANCE_MAX_KM:50,MATCH_AB_TEST_KEYS:[],MATCH_AI_HINTS_ENABLED:!0},updatedAt:(new Date).toISOString(),updatedBy:"system"};return this.configCache=t,t}}async updateConfig(e){try{const t=await i.put("/matching/config",e);return this.configCache=t.data.config,t.data.config}catch(t){const e=t instanceof Error?t:new Error(String(t));throw I.error("Failed to update config",e),e}}}const w=new m;export{m as MatchingAPI,w as matchingAPI};
